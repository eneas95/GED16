---
lang: pt  
title: "GED-16: Análise de Regressão"
subtitle: "AULA02: Prática (1o. semestre/2023)"
author: 
- Lucas Inamine de Angelo 
- Luiz Vasconcelos Júnior
- Marcos Antônio dos Santos Fonseca
date: "2023-03-29"  
format:
  html:
    theme: cosmo
execute:
  echo: true
  eval: true
  warning: false    
---

----

### Introdução

Abalone é um tipo de molusco que vive em águas marinhas costeiras em diversas regiões do globo. A concha do abalone apresenta tamanho que varia entre 10 a 25cm e sua coloração interior iridescente nacarada é muito valorizada na confecção de jóias e ornamentos; além disso, a carne do animal é considerada uma iguaria em muitos países. Devido ao seu alto valor comercial e consequente pesca excessiva, além da degradação de seu habitat pela ação humana, diversas espécies de abalone atualmente correm risco de extinção. Existem mais de 100 espécies de abalone ao redor do mundo, das quais cerca de 15 são produzidas por meio de aquicultura. Determinar a idade do abalone de maneira acurada é importante tanto em termos comerciais (o valor comercial do abalone está associado à sua idade) bem como em termos ambientais (condições ambientais podem afetar a saúde do animal). A idade do animal pode ser determinada a partir da contagem do número de anéis na concha, utilizando um microscópio, a partir de um procedimento delicado e trabalhoso.


![Abalone (Image by <a href="https://pixabay.com/users/lisaleo-3220940/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4919586">Lisa Yount</a> from <a href="https://pixabay.com//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4919586">Pixabay</a>)](img/abalone.jpg){width=80%}

Os dados disponíveis no arquivo `data/abalone/abalone.data` foram
obtidos no [UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/Abalone) e são bastante utilizados na investigação de métodos de Machine Learning. Tais dados foram coletados a partir do estudo original:

Warwick J Nash, Tracy L Sellers, Simon R Talbot, Andrew J Cawthorn and
	Wes B Ford (1994) "The Population Biology of Abalone (_Haliotis_
	species) in Tasmania. I. Blacklip Abalone (_H. rubra_) from the
	North	Coast and Islands of Bass Strait", Sea Fisheries Division,
	Technical Report No. 48 (ISSN 1034-3288).

O principal objetivo do projeto era determinar a idade do molusco a partir de medidas físicas do animal mais fáceis de serem obtidas. Os dados originais foram pré-processados no sentido de remover observações faltantes e os valores das variáveis contínuas foram dividos por 200. Há um total de 4177 observações coletadas para 9 variáveis:

1. `sex`: sexo do animal (M, F, I)
2. `length`: maior comprimento da concha (mm)
3. `diameter`: comprimento perpendicular à `length` (mm)
4. `height`: comprimento da carne da concha (mm)
5. `whole_w`: peso do animal (g)
6. `shucked_w`: peso da carne (g)
7. `viscera_w`: peso das vísceras (g)
8. `shell_w`: peso da concha (g)
9. `rings`: número de anéis (a idade é obtida somando 1.5)

Mais informações a respeito dos dados podem ser obtidas no arquivo `data/abalone/abalone.names`.

----

### Análise Exploratória de Dados

O primeiro passo realizado foi limpar a área de trabalho com o comando `rm(list = ls())`, para assim importar a base e dados presente no arquivo `abalone.data`, armazenado no *github*. Os dados então são lidos e armazenados em um objeto chamado *abalone*, do tipo tabela. Não há cabeçalho no arquivo de entrada, portanto, foram atribuídos nomes para as colunas do objeto tabela.

- Bibliotecas utilizadas:

```{r libraries}
#| warning: false
#| message: false
library(tinytex)
library(readr)
library(ggplot2)
library(pander)
library(details)
library(sessioninfo)
library(tidyverse)
library(gridExtra)
```

- A Equipe, por razões de reproducibilidade, optou por importar a base de dados de um repositório do *github*:
  
```{r importdata}
#Limpar a área de trabalho
rm(list=ls())
#carregar os dados
abalone <- read_csv("https://raw.githubusercontent.com/eneas95/GED16/main/Pratica01/data/abalone/abalone.data", col_names = FALSE)
# atribuir nomes às variáveis (colunas da tabela)
names(abalone) <- c("sex", "length", "diameter", "height", "whole_w", "shucked_w", "viscera_w", "shell_w", "rings")
```
- Utilizando o comando `str(abalone)`, foi obtida a seguinte estrutura dos dados:

```{r sr1}
# Verifica estrutura dos dados
str(abalone)
```
FOi verificado que existe 4.177 observações e 9 variáveis. Cada observação corresponde a uma linha do objeto tabela `abalone`, conforme exibido logo abaixo.

```{r table}
pander(abalone[1:10,], caption = "Primeiras 10 linhas do dataset abalone.")
```

Ademais, percebe-se que `sex` está codificado como um *character*, porém, para realização da análise exploratória, deseja-se que ela seja recodificada como *factor*. A variável *rings* também será recodificada com um *integer* no intuito de ocupar menos espaço na memória.

```{r names}
#Verificar os nomes das variáveis
names(abalone)
```

- Agora, recodificando as variáveis em questão:
```{r recode}
abalone <- abalone %>%
  mutate_at("sex", as.factor) %>%
  mutate_at("rings", as.integer)
str(abalone)
```
Utilizando a função `str(abalone)` novamente, verificou-se que agora os dados estão codificados adequadamente.

No intuito de se obter resumos numéricos unidimensionais foi utilizada a função `summary`. Para as variáveis categóricas, a função `summary` retorna o número de observações em cada classe.

```{r summary1}
summary(abalone)
```
É possível perceber por meio da função `summary` que, apesar de não haver dados faltantes, existem inconsistências na coluna `height`, visto que a altura do molusco deve ser sempre um valor numérico maior do que zero.
No entanto, é necessário analisar a quantidade de dados inconsistentes nessa amostra para então decidir como proceder.

- A Equipe desenvolveu o seguinte código em R para determinar esta quantidade:

```{r countzero}
error <- 0.000000001
count_r <- 0
for (height in abalone$height){
  if(height <= error){
    count_r <- count_r+1
  }
}
count_r
  
```
Logo, como há apenas 2 casos com inconsistências, a Equipe decidiu desprezá-los e retirá-los do *dataset*, uma vez que eram poucos comparados com o total de 4.177 observações.

- Para tal, foi utilizada a função `filter´:
```{r filter2}
abalone <- abalone %>% filter(height > 0)
summary(abalone)
```
```{r table2, echo=FALSE}
abalone
```


As 2 linhas com altura 0 foram retiradas do *dataset* e, por conseguinte, restaram 4.175 observações. Agora, é possivel gerar gráficos a fim de explorar a relação entre as variáveis.

#### Resumos gráficos unidimensionais

Por meio de histograma, é possível apresentar a distribuição dos valores observados para uma variável. No caso, foram gerados os histogramas para as variáveis `length`e `height`.

```{r lengthhist}
#| message: false 
# Histograma de `lenght`
ggplot(abalone, aes(x = length)) +
  geom_histogram(aes(y = after_stat(density))) +
  # adiciona linha de densidade estimada (suavização)
  geom_density(lwd = 1, colour = 4,
               fill = 4, alpha = 0.25) +
  # adiciona dispersão unidimensional de `length`
  geom_rug(alpha = 0.5)
```
```{r heighthist, eval=FALSE}
#| message: false 
# Histograma de `height`
ggplot(abalone, aes(x = height)) +
  geom_histogram(aes(y = after_stat(density))) +
  # adiciona linha de densidade estimada (suavização)
  geom_density(lwd = 1, colour = 4,
               fill = 4, alpha = 0.25) +
  # adiciona dispersão unidimensional de `height`
  geom_rug(alpha = 0.5)
```

A curva em azul claro adicionada ao histograma é a curva de densidade estimada, a qual estima a distribuição da variável de resposta. A curva de densidade estimada é contínua, diferentemente de um histograma, logo, proporciona uma melhor representação da distribuição de uma variável numérica que um histograma.

Também foram gerados os gráficos *boxplot* para essas duas variáveis:

```{r boxplot1}
# Boxplot de `length`
ggplot(abalone, aes(x = length, y = "")) +
  # adiciona barras de erros
  geom_errorbar(stat = "boxplot", width = 0.1) +
  # adiciona boxplot
  geom_boxplot () +
  # adiciona dispersão unidimensional de `length`
  geom_rug(alpha = 0.5) +
  # adiciona rótulo aos eixos
  labs(y = "", x = "length")
```

```{r boxplot2}
# Boxplot de `height`
ggplot(abalone, aes(x = height, y = "")) +
  # adiciona barras de erros
  geom_errorbar(stat = "boxplot", width = 0.1) +
  # adiciona boxplot
  geom_boxplot () +
  # adiciona dispersão unidimensional de `height`
  geom_rug(alpha = 0.5) +
  # adiciona rótulo aos eixos
  labs(y = "", x = "height")
```
Com relação ao gráfico *boxplot*, ele nos dá 5 estatísticas robustas e também mostra possíveis *outliers*. A caixa é delimitada pelos quartis inferior e superior e a linha no centro corresponde à mediana. Portanto, 50% das observações se encontram entre os valores que determinam as extremidades da caixa. O comprimento da caixa é chamado distância ou amplitude inter-quartis (ou IQR) e corresponde à diferença entre os quartis superior e inferior.

As linhas horizontais que se afastam da caixa são os “whiskers”, cujo comprimento é tal que a distância máxima entre as duas extremidades vale 4 * IQR. Qualquer valor além dos “whiskers” é marcado como um ponto extremo, ou *outlier*.

Logo, é possível vizualizar pelo *boxplot* da variável *height* que existem 2 pontos marcados como *outliers*. 

#### Resumos gráficos multidimensionais

No intuito de comparar visualmente diferentes distribuições e analisar a relação entre as variáveis, foram gerados os seguintes boxplots, histogramas e curvas de densidade estimada, para diferentes categorias. Primeiramente, a Equipe decidiu comparar o número de anéis (rings) com as distintas categorias da variável `sex`. Será que o número de anéis difere de acordo com o sexo?

```{r mult1}
# Boxplots
ggplot(abalone, aes(x = rings, y = sex)) +
  geom_boxplot()
```

```{r mult2}
# Histogramas 
ggplot(abalone, aes(x = rings, fill = sex)) +
  geom_histogram(alpha = 0.25, position = "identity")
```

```{r mult3}
# Densidades
ggplot(abalone, aes(x = rings, fill = sex)) +
  geom_density(alpha = 0.5, position = "identity")
```

Pelos gráficos acima, não é possível chegar a uma conclusão. O *boxplot* e o gráfico de densidades estimadas, a princípio, exibem distribuições semelhantes para o número de anéis tanto para a sexo masculino quanto para o feminino.

Em seguida, para analisar a relação entre variáveis quantitativas, foram gerados gráficos de dispersão:

```{r dispersao}
# Matriz de gráficos de dispersão (base R)
plot(abalone[, -c(1)])
```

```{r ggally}
#| warning: false
#| message: false
# Matriz de gráficos de dispersão (GGali)
library(GGally)
ggpairs(abalone[, -c(1)])
```

A partir dos gráficos acima, é possível ter uma ideia geral de como as variáveis quantitativas se relacionam. Por exemplo, as variáveis `length`, `diameter`, `height`, `whole_w`, `shucked_w`, `viscera_w` e `shell_w` possuem elevados coeficientes de correlação entre si. A variável `rings` é aquela que mais distoa nesse sentindo.

```{r cor1}
# Coef. de correlacao
cor (abalone$rings, abalone$shucked_w)
```
O número de anéis da concha (rings) possui uma correlação baixa com o peso da carne (shucked_w), por exemplo.

```{r cor2}
cor (abalone$rings, abalone$shell_w)
```
Todas as correlações entre as variáveis são positivas, o que faz sentido dado que está se analisando peso, tamanho, altura e número de anéis. Além disso, percebe-se que o número de aneis é o menos correlacionável com as outras variáveis. Porém, a maior correlação é com o peso da concha, o que faz sentido de certa maneira pois quanto maior a concha, maior o número de anéis.

```{r rings_shell}
ggplot(abalone) +
  geom_point(aes(x= rings, y = shell_w), na.rm = TRUE)
```
Dessa forma, a Equipe formulou a seguinte hipótese: à medida em que o animal envelhece, sua concha aumenta de tamanho e peso, o que, consequentemente, aumenta o número de anéis da concha.

#### Transformações

A relação estatística entre a variável altura e peso do animal é curvilínea conforme mostra o gráfico abaixo, o qual também evidencia a alta correlação entre essas duas variáveis.

```{r h_whole}
ggplot(abalone) +
  geom_point(aes(x= height, y = whole_w), na.rm = TRUE)
```
Existem 2 outliers de acordo com o gráfico acima, o que confere com o que fora obtido nos gráficos *boxplot*. Ou seja, há 2 objetos com uma altura muito divergente da média.

Além disso, é possível realizar certas transformções á variàvel `height` a fim de auxiliar no processo de formulação de novas hipóteses.

```{r trans}

ggplot(abalone) +
  geom_point(aes(x= sqrt(height), y = whole_w), na.rm = TRUE)

ggplot(abalone) +
  geom_point(aes(x= 1/height, y = whole_w), na.rm = TRUE)

ggplot(abalone) +
  geom_point(aes(x= log2(height), y = whole_w), na.rm = TRUE)
```

----


### Análise de Regressão

#### Parte 1: Implementação de um modelo de regressão linear simples para a variável de resposta `length`, utilizando cada uma das seguintes variáveis explicativas  `diameter`, `shucked_w`, `shell_w` e `rings`:

Primeiramente, fi analisado se o modelo de regressão linear simples é adequado por meio dos gráficos de dispersão e do coeficiente de correlação:


```{r dispersao1}
#Diameter
ggplot(abalone) +
  geom_point(aes(x= length, y = diameter), na.rm = TRUE)
#shucked_w
ggplot(abalone) +
  geom_point(aes(x= length, y = shucked_w), na.rm = TRUE)
#shell_w
ggplot(abalone) +
  geom_point(aes(x= length, y = shell_w), na.rm = TRUE)
#rings
ggplot(abalone) +
  geom_point(aes(x= length, y = rings), na.rm = TRUE)
```

Por meio dos gráficos gerados acima, é possível assumir que o modelo de regressão linear simples é adequado. Porém, no intuito de  oferecer mais embasamento a esta decisão, foram calculados os coeficientes de correlaçao:

```{r cor1_1}
#Diameter
cor(abalone$length, abalone$diameter)
#shucked_w
cor(abalone$length, abalone$shucked_w)
#shell_w
cor(abalone$length, abalone$shell_w)
#rings
cor(abalone$length, abalone$rings)
```
Dessa forma, a menor correlação obtida foi entre o par `length-rings`, porém, como o resultado foi relativamente considerãvel (0.5564644), é possível concluir que o modelo de regressão pode ser aplicado para os casos analisados, visto que, para os outros 3 pares a correlação é próxima de 1, isto é, fortemente linear.
  
  Em seguida, foram criadas novas variáveis a fim de tornar a análise mais simples e objetiva:
  
  - Par `length`-`diameter`:
  
```{r var1_1}
# Constrói nova base de dados para análise
abalone_len_diam <- abalone |>
  # seleciona apenas variáveis de interesse
  select(length, diameter)

abalone_len_shucked <- abalone |>
  select(length, shucked_w)

abalone_len_shell <- abalone |>
  select(length, shell_w)

abalone_len_rings <- abalone |>
  select(length, rings)

# gera resumo dos novos dados  
summary(abalone_len_diam)
```
Sabe-se que o diâmetro deve ser maior que zero, logo o coeficiente linear da reta estimada não tem significado prático.

```{r redmod1}
# Constrói modelo de regressao linear simples (rls)
abalone_rls_len_diam <- lm(length ~ diameter, data = abalone_len_diam)
# variável de resposta: `lenght` 
# variável explicativa: `diameter`

# retorna coeficientes estimados do modelo de rls
abalone_rls_len_diam
```
O modelo obtido nesse caso foi de 1a. Ordem, A variável de resposta é `length`, enquanto que a variável explicativa é `diameter`.

 - Par `length`-`shucked_w`:

```{r summary2}
summary(abalone_len_shucked)
```
Assim como foi feito a análise do diâmetro, não fa sentido o peso da carne do animal ser nulo. Logo, ele deve ser maior do que zero.

```{r redmod2}
# Constrói modelo de regressao linear simples (rls)
abalone_rls_len_shucked <- lm(length ~ shucked_w, data = abalone_len_shucked)
# variável de resposta: `lenght` 
# variável explicativa: `shucked_w`

# retorna coeficientes estimados do modelo de rls
abalone_rls_len_shucked
```
O modelo obtido também foi de 1a. Ordem, A variável de resposta é `length`, enquanto que a variável explicativa nesse caso é `shucked_w`.

 - Par `length`-`shell_w`:

```{r summary3}
summary(abalone_len_shell)
```
Analogamente aos casos anteriores, o coeficiente linear da reta, isto é, a situação em que o peso da concha é nulo, não deve ser incluído no modelo. Tal cenário condiz com a situação em que o abalone é jovem o suficiente para sua concha ainda não ter se formado, porém o comprimento da concha deveria ser nulo por consequência, o que não é o caso. O resultado obtido foi de 1a. ordem, a variável de resposta é `length` e a explicativa é `shell_w`.

```{r modred3}
# Constrói modelo de regressao linear simples (rls)
abalone_rls_len_shell <- lm(length ~ shell_w, data = abalone_len_shell)
# variável de resposta: `lenght` 
# variável explicativa: `shell_w`

# retorna coeficientes estimados do modelo de rls
abalone_rls_len_shell
```

 - Par `length`-`rings`:

```{r summary4}
summary(abalone_len_rings)
```
Analogamente, o modelo não deve comportar o caso em que o número de anéis é zero, ou seja, o caso em que o abalone é relativamente um recém-nascido.Pois, se o número de anéis da concha é zero, o comprimento da concha também deveria ser nulo. O resultado também é de 1a. ordem, a variável de resposta é `length` e a explicativa é `rings`.

```{r modred4}
# Constrói modelo de regressao linear simples (rls)
abalone_rls_len_rings <- lm(length ~ rings, data = abalone_len_rings)
# variável de resposta: `lenght` 
# variável explicativa: `rings`

# retorna coeficientes estimados do modelo de rls
abalone_rls_len_rings
```
  
  **Interpretação do Modelo Ajustado:**
  
  - Par `length`-`diameter`:
  
  `lenght = 0.03692 + 1.19416.diameter` (Modelo Ajustado)
  
  Nesse caso, o coeficiente linear não tem significado prático, pois não faz sentido o diâmetro do animal ser nulo. Porém, nota-se que quando o diâmetro é zero, `length` assumirá um valor aproximadamente zero, o que indica que o abalone ainda não nasceu. O coeficiente angular indica o aumento no comprimento da concha para cada milímetro de aumento no diâmetro. A relação é positiva.
  
```{r reta1}
#| message: false
# gera gráfico de dispersão
ggplot(abalone_len_diam, aes(x = diameter, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada
  geom_smooth(method = lm, se = FALSE)
```
  
  - Par `length`-`shucked_w`:
  
  `lenght = 0.3495 + 0.4857.shucked_w` (Modelo Ajustado)
  
  O coeficiente linear não tem significado prático aqui, pois não faz sentido o peso da carne do abalone ser nulo e o comprimento da concha não. O coeficiente angular indica um aumento no comprimento da concha para cada 1g de aumento no peso da carne. A relação é positiva.
  
```{r reta2}
#| message: false
# gera gráfico de dispersão
ggplot(abalone_len_shucked, aes(x = shucked_w, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)
```

  - Par `length`-`shell_w`:
  
  `lenght = 0.3390  +  0.7749.shell_w` (Modelo Ajustado)
  
  O coeficiente linear também não possui significado prático, pois não fa sentido o peso da concha ser nulo, enquanto o comprimento da concha ser aproximadamente 339 mg. O coeficiente angular mostra que um aumento de 1g no peso da concha acarreta em um aumento no comprimento da própria. A relação é positiva.
  
```{r reta3}
#| message: false
# gera gráfico de dispersão
ggplot(abalone_len_shell, aes(x = shell_w, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)
```

  - Par `length`-`rings`:
  
  `lenght = 0.31818 + 0.02072.rings` (Modelo Ajustado)
  
  O coeficiente linear não tem sentido prático, pois se o número de anéis é zero, este fato deveria implicar em um comprimento da concha igual a zero. O coeficiente angular indica um aumento no comprimento da concha para cada incremento no número de anéis.
  
```{r reta4}
#| message: false
# gera gráfico de dispersão
ggplot(abalone_len_rings, aes(x = rings, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)
```
  
  Analisando o resumo do modelo de regressão ajustado:
  
```{r red_summary1}
#Obtenção do sigma e do R2
summary1 <- summary(abalone_rls1)
sigma1 <- summary1$sigma
r2_1 <- summary1$r.squared
sigma1
#Cálculo do MSE
mse1 <- sigma1^2
mse1
```
  Logo, o valor de `sigma` nesse caso é igual a 0.01944569. E sabe-se que o estimador da variância dos erros (MSE) é  igual ao `sigma` elevado ao quadrado.
  
  MSE = 0.000378135
  
```{r reg_summary2}
#Obtenção do sigma e do R2
summary2 <- summary(abalone_rls2)
sigma2 <- summary2$sigma
r2_2 <- summary2$r.squared
sigma2
#Cálculo do MSE
mse2 <- sigma2^2
mse2
```
   O valor de `sigma` é 0.05287079. Elevando sigma ao quadrado é possível obter o valor do MSE:
   
   MSE = 0.002795321
  
```{r red_summary3}
#Obtenção do sigma e do R2
summary3 <- summary(abalone_rls3)
sigma3 <- summary3$sigma
r2_3 <- summary3$r.squared
sigma3
#Cálculo do MSE
mse3 <- sigma3^2
mse3
```
  O valor de `sigma` é 0.05273337. Elevando sigma ao quadrado é possível obter o valor do MSE:
  
  MSE = 0.002780808
  
```{r red_summary4}
#Obtenção do sigma e do R2
summary4 <- summary(abalone_rls4)
sigma4 <- summary4$sigma
r2_4 <- summary4$r.squared
sigma4
#Cálculo do MSE
mse4 <- sigma4^2
mse4
```
  O valor de `sigma` é 0.09977409. Elevando `sigma` ao quadrado é possível obter o valor do MSE:
  
  MSE = 0.009954869
  
```{r mse_results}
mse1

mse2

mse3

mse4
```
  
  Portanto, dado que o MSE é um estimador da variância para o modelo de regressão linear simples, a variável explicativa que tiver o menor valor de MSE é aquele que possui a menor variabilidade em torno da reta de regressão ajustada, no caso, a variável `diameter`. Importante ressaltar que os valores de MSE para as variáveis `shell_w` e `shucked_w` obtidos foram semelhantes, ou seja, possuem variablidades semelhantes em torno da reta de regressão.
  
```{r r2square}
r2_1

r2_2

r2_3

r2_4
```
  - Par `length`-`diameter`:  R-squared:  0.9737772
  - Par `length`-`shucked_w`: R-squared:  0.8061509
  - Par `length`-`shell_w`:   R-squared:  0.8071573
  - Par `length`-`rings`:     R-squared:  0.3096526
  
  O coeficiente de determinação *R-squared* é a fração em que a variância dos erros é menor do que a variância das variáveis dependentes. Este coeficiente indica o quão bem o modelo de regressão aplicado se aproxima dos dados reais. Logo, um *R-squared* de 0.974, isto é, próximo de um 1, obtido pela variável explicativa `diameter`, indica uma maior redução na variabilidade da variável resposta `length'.
  
  
#### Parte 2: Construção de um modelo de regressão linear simples para cada nível da variável `sex`.

Para cada nível da variável `sex`, foi construído um modelo de regressão para a variável de resposta `length` em função de `diameter`. 

Para analisar cada nível da variável `sex`, foi criada novas variáveis a fim de facilitar a análise, utilizando para tal a função `filter()`.

Primeiro, vamos separar o *dataset* para cada nível de `sex`. Dessa forma, foi criada 3 novas variáveis, uma para valor possível de `sex`(M, F e I).

```{r separasex_m}
sexo <- 'M'
abalone2_m <- abalone %>%
  filter(sex == sexo) %>%
  select(length, diameter)
abalone2_m
```

```{r separasex_f}
sexo <- 'F'
abalone2_f <- abalone %>%
  filter(sex == sexo) %>%
  select(length, diameter)
abalone2_f
```

```{r separasex_i}
sexo <- 'I'
abalone2_i <- abalone %>%
  filter(sex == sexo) %>%
  select(length, diameter)
abalone2_i
```

Nota-se que a soma das linhas de cada *subset* é igual total de 4175 observações, ou seja, a separação da base de dados foi realiada corretamente.

  1. Agora, verfica-se que a implementação de um modelo de regressão linear simples é adequada por meio da construção dos gráficos de dispersão:

```{r dispersao2}
#M
ggplot(abalone2_m) +
  geom_point(aes(x= length, y = diameter), na.rm = TRUE)
#F
ggplot(abalone2_f) +
  geom_point(aes(x= length, y = diameter), na.rm = TRUE)
#I
ggplot(abalone2_i) +
  geom_point(aes(x= length, y = diameter), na.rm = TRUE)
```
Pelos gráficos acima, percebe-se que o modelo de regressão linear é adequado. Porém, para dar mais embasamento e esta decisão, foram calculados os coeficientes de correlação:

```{r corr2}
#M
cor(abalone2_m$length, abalone2_m$diameter)
#F
cor(abalone2_f$length, abalone2_f$diameter)
#I
cor(abalone2_i$length, abalone2_i$diameter)
```
Todos os coeficientes de correlação são muito próximos de 1. Logo, aplicar um modelo de regressão linear simples é dequado para esses casos.

  
```{r summary_m}
summary(abalone2_m) 
```
```{r modred_m}
# Constrói modelo de regressao linear simples (rls)
abalone2_rls_m <- lm(length ~ diameter, data = abalone2_m)
# variável de resposta: `lenght` 
# variável explicativa: `diameter`

# retorna coeficientes estimados do modelo de rls
abalone2_rls_m
```
```{r modred_f}
# Constrói modelo de regressao linear simples (rls)
abalone2_rls_f <- lm(length ~ diameter, data = abalone2_f)
# variável de resposta: `lenght` 
# variável explicativa: `diameter`

# retorna coeficientes estimados do modelo de rls
abalone2_rls_f
```
```{r modred_i}
# Constrói modelo de regressao linear simples (rls)
abalone2_rls_i <- lm(length ~ diameter, data = abalone2_i)
# variável de resposta: `lenght` 
# variável explicativa: `diameter`

# retorna coeficientes estimados do modelo de rls
abalone2_rls_i
```


  **Modelos Ajustados**
  
  1. Para `sex` igual a `M`: `length = 0.03653 + 1.19480.diameter`
  
  2. Para `sex` igual a `F`: `length = 0.04288 + 1.17918.diameter`
  
  3. Para `sex` igual a `I`: `length = 0.02995 + 1.21840.diameter`
  
```{r}
#| message: false
#M
ggplot(abalone2_m, aes(x = diameter, y = length)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE)
#F
ggplot(abalone2_f, aes(x = diameter, y = length)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE)
#I
ggplot(abalone2_i, aes(x = diameter, y = length)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE)
```
  
```{r}
#M
line1 <- function(x) 0.03653 + 1.19480*x
line2 <- function(x) 0.04288 + 1.17918*x
line3 <- function(x) 0.02995 + 1.21840*x

x <- seq(0, 0.63, by = 0.01)

y1 <- sapply(x, line1)
y2 <- sapply(x, line2)
y3 <- sapply(x, line3)

plot(x, y1, type = "l", col = "blue", lwd = 2, xlab = "diameter", ylab = "length")
lines(x, y2, type = "l", col = "green", lwd = 2)
lines(x, y3, type = "l", col = "red", lwd = 2)
legend("topleft", legend = c("M", "F", "I"), col = c("blue", "green", "red"), lty = 1, lwd = 2)
```
  
  
  Conforme o gráfico apresentado acima com as 3 retas de regressão, nota-se visualmente que as funções e regressão obtidas são semelhantes. Isto ocorre pois os coeficientes das retas de regressão possuem valores próximos uns dos outros.
  
  2. Em seguida, foi calculado o MSE para cada nível da variável sex:
  
```{r mse_sex1}
#Obtenção do sigma e do R2
summary2_m <- summary(abalone2_rls_m)
sigma2_m <- summary2_m$sigma

summary2_f <- summary(abalone2_rls_f)
sigma2_f <- summary2_f$sigma

summary2_i <- summary(abalone2_rls_i)
sigma2_i <- summary2_i$sigma

#Cálculo do MSE
mse2_m <- sigma2_m^2
mse2_f <- sigma2_f^2
mse2_i <- sigma2_i^2

mse2_m
mse2_f
mse2_i
```
  - MSE para o nível 'M': 0.0003784367
  - MSE para o nível 'F': 0.0004234816
  - MSE para o nivel 'I": 0.0003274022
  
  Logo, como o indicador MSE é um estimador da variância para o modelo de regressão linear simples, nota-se que a variabilidade em torno da reta de regressão ajustada é semelhante para os 3 níveis da variável `sex`, uma vez que os valores obtidos são próximos.   
  
  3. No próximo passo, foram desenvolvidas as retas de regressão para cada nível de `sex` com intervalo de confiança 95% para o coeficiente angular:
  
```{r ic2_m}
# IC para os coeficientes
confint.lm(abalone2_rls_m, level = 0.95)
```
  Dessa forma, conclui-se, para o nível 'M' da variável `sex`, com 95% de confiança que o maior comprimento da concha (em `length`) aumenta entre 1.18323483 e 1.20637504 para cada acréscimo unitário em `diameter`. O coeficiente angular é positivo, o que faz sentido, uma vez que o comprimento da concha deve acompanhar o aumento de seu diâmetro.
  
```{r ic2_f}
# IC para os coeficientes
confint.lm(abalone2_rls_f, level = 0.95)
```
Logo, conclui-se, para o nível 'F' da variável `sex`, com 95% de confiança que o maior comprimento da concha (em `length`) aumenta entre 11.16343706 e 1.1949253 para cada acréscimo unitário em `diameter`. O coeficiente angular é positivo, o que faz sentido, uma vez que o comprimento da concha deve acompanhar o aumento de seu diâmetro.
  
```{r ic2_i}
# IC para os coeficientes
confint.lm(abalone2_rls_m, level = 0.95)
```
  Por fim, conclui-se, para o nível 'I' da variável `sex`, com 95% de confiança que o maior comprimento da concha (em `length`) aumenta entre 1.18323483 e 1.20637504 para cada acréscimo unitário em `diameter`. O coeficiente angular é positivo, o que faz sentido, uma vez que o comprimento da concha deve acompanhar o aumento de seu diâmetro.
  
  4. Em seguida, foi estimada a resposta esperada com `diameter=90` para cada nível da variável `sex`.
  
```{r respesp2_m}
# novo valor da variável explicativa
Xh <- data.frame(diameter=90)

# intervalo de confiança para resposta esperada
ic <- predict.lm(abalone2_rls_m, newdata = Xh, 
           interval="confidence", level = 0.95)
ic
```
O valor ajustado para o sexo 'M' é 107.569, o qual é a estimativa pontual e corresponde à resposta do modelo para `diameter=90`. O intervalo de confiança para a resposta média é `r round(ic[2], digits =1)`  e `r round(ic[3], digits =1)`. Portanto, é possível concluir com 95% de confiança que o `length` esperado para um animal com `diameter=90` deve estar entre 106.5327 e 108.6052.

```{r respesp2_f}
# novo valor da variável explicativa
Xh <- data.frame(diameter=90)

# intervalo de confiança para resposta esperada
ic <- predict.lm(abalone2_rls_f, newdata = Xh, 
           interval="confidence", level = 0.95)
ic
```
Nesse caso, valor ajustado para o sexo 'F' é 106.1692, o qual é a estimativa pontual e corresponde à resposta do modelo para `diameter=90`. O intervalo de confiança para a resposta média é (104.7594, 107.579). Portanto, é possível concluir com 95% de confiança que o `length` esperado para um animal com `diameter=90` deve estar entre 104.7594 e 107.579.

```{r respesp2_i}
# novo valor da variável explicativa
Xh <- data.frame(diameter=90)

# intervalo de confiança para resposta esperada
ic <- predict.lm(abalone2_rls_i, newdata = Xh, 
           interval="confidence", level = 0.95)
ic
```
Nesse caso, valor ajustado para o sexo 'I' é 109.6856, o qual é a estimativa pontual e corresponde à resposta do modelo para `diameter=90`. O intervalo de confiança para a resposta média é (108.6986, 110.6726). Portanto, é possível concluir com 95% de confiança que o `length` esperado para um animal com `diameter=90` deve estar entre 108.6986 e 110.6726.
  
  A partir dessas análises, é possível realizar uma previsão da respsota para uma nova observação.
  
  5. Dessa maneira, foram construídos intervalos de previsão para um novo animal de cada sexo que possua `diameter=90`:
  
```{r predict2_m}
# novo valor da variável explicativa
Xo <- data.frame(diameter = 90)

# intervalo de confiança
ip_m <- predict.lm(abalone2_rls_m, newdata = Xo, 
           interval="prediction", level = 0.95)
ip_m
```
  Nota-se que o valor da estimativa pontual permanece o mesmo, visto que ele indica o valor de resposta previsto pelo modelo de regressão simples. Ademais, o intervalo de previsão para a nova observação do sexo masculino com diâmetro de 90 é dado por [106.532, 108.6059]. Esse intervalo torna possível concluir com 95% de confiança que uma faixa plausível de valores de `length`para o próximo animal do sexo masculino com `diameter=90` está entre 106.532 e 108.6059. Importante ressaltar que houve pouca variação com o intervalo obtido no passo anterior ([106.5327, 108.6052]).
  
```{r predict2_f}
# novo valor da variável explicativa
Xo <- data.frame(diameter = 90)

# intervalo de confiança
ip_f <- predict.lm(abalone2_rls_f, newdata = Xo, 
           interval="prediction", level = 0.95)
ip_f
```
  O valor da estimativa pontual permanece o mesmo. O intervalo de previsão para a nova observação do sexo feminino com diâmetro de 90 é dado por [104.7588, 107.5796]. Esse intervalo torna possível concluir com 95% de confiança que uma faixa plausível de valores de `length`para o próximo animal do sexo feminino com `diameter=90` está entre 104.7588 e 107.5796. Importante ressaltar que houve pouca variação com o intervalo obtido no passo anterior ([104.7594, 107.579]).
  
```{r predict2_i}
# novo valor da variável explicativa
Xo <- data.frame(diameter = 90)

# intervalo de confiança
ip_i <- predict.lm(abalone2_rls_i, newdata = Xo, 
           interval="prediction", level = 0.95)
ip_i
```
  Nesse caso, o valor da estimativa pontual permanece o mesmo. O intervalo de previsão para a nova observação do sexo indefinido com diâmetro de 90 é dado por [108.698, 110.6732]. Esse intervalo torna possível concluir com 95% de confiança que uma faixa plausível de valores de `length`para o próximo animal de sexo indefinido com `diameter=90` está entre 108.698 e 110.6732. Importante ressaltar que houve pouca variação com o intervalo obtido no passo anterior ([108.6986, 110.6726]).

#### Parte 3: Construção de um modelo de regressão linear simples para cada nível da variável `sex` em que a variável resposta é "length" e a variável explicativa é "shell_w".

##### A. Obtendo os modelos de regressão ajustados.
```{r filtrar sexo p shell_w}

abalone2_F = abalone[abalone$sex == "F", c(2, 8)];
abalone2_M = abalone[abalone$sex == "M", c(2, 8)];
abalone2_I = abalone[abalone$sex == "I", c(2, 8)];

```

```{r modelos ajustado p shell_w por sexo}
reg_lin_2f = lm(length ~ shell_w, data = abalone2_F)

b0_2f = summary(reg_lin_2f)$coefficients[1];
b1_2f = summary(reg_lin_2f)$coefficients[2];


reg_lin_2m = lm(length ~ shell_w, data = abalone2_M)

b0_2m = summary(reg_lin_2m)$coefficients[1];
b1_2m = summary(reg_lin_2m)$coefficients[2];

reg_lin_2i = lm(length ~ shell_w, data = abalone2_I)

b0_2i = summary(reg_lin_2i)$coefficients[1];
b1_2i = summary(reg_lin_2i)$coefficients[2];

```

```{r retas ajustadas}
reg_lin_2f
reg_lin_2m
reg_lin_2i
```
**Modelos Ajustados**
  
  1. Para `sex` igual a `F`: `length =  0.4000 + 0.5931.sheel_w`
  
  2. Para `sex` igual a `M`: `length =  0.3687 + 0.6835.shell_w`
  
  3. Para `sex` igual a `I`: `length =  0.2775 + 1.1739.shell_w`

```{r plot_retas3}
#| message: false
# gera gráfico de dispersão
ggplot(abalone2_F, aes(x = shell_w, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)

# gera gráfico de dispersão
ggplot(abalone2_M, aes(x = shell_w, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)

# gera gráfico de dispersão
ggplot(abalone2_I, aes(x = shell_w, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)
```
  
##### B. As funções de regressão estimadas são semelhantes para todos os níveis da variável sex? Discuta.

As retas de regressão encontradas diferem para cada nível da variável sex. Há uma descrepância maior da reta de regressão do nível sex = "I", em relação aos outros níveis, os quais apresentam retas de regressão semelhantes. Em relação aos valores dos coeficientes b_0, embora valor "0" esteja no escopo da variável explicativa(peso da concha), o valor de b_0 não corresponde muito à realidade, já que para shel_w = 0, verifica-se que os valores de length tendem também a "0", o que faz sentido já que, no nascimento do molusco, provavelmente, o peso da concha é pequeno, ou mesmo, a concha inexiste.


```{r corr}
#F
cor(abalone2_F$length, abalone2_F$shell_w)
#M
cor(abalone2_M$length, abalone2_M$shell_w)
#I
cor(abalone2_I$length, abalone2_I$shell_w)
```
Verifica-se, também, que a correlação entre as variáveis para os 3 níveis de sex assumem valores próximos a 1, o que indica que a as variáveis possuem uma boa correlação e que esta é positiva.

##### C. Cálculo do MSE para cada nível da variável sex. A variabilidade em torno da reta de regressão ajustada é semelhante para todos os níveis?
```{r mse3}
mse_2f = mean(residuals(summary(reg_lin_2f))^2)
mse_2m = mean(residuals(summary(reg_lin_2m))^2)
mse_2i = mean(residuals(summary(reg_lin_2i))^2)

mse_2f
mse_2m
mse_2i
```
Referência para o cálculo de mse: https://stats.stackexchange.com/questions/110999/r-confused-on-residual-terminology.

O MSE assume valores baixos para os 3 modelos, o que ratifica que as variáveis são bem correlacionadas. No entanto, há diferenças dos valores entre os 3 modelos, o que indica uma variabilidade menor para conjunto de dados para o sexo feminino e uma variabilidade maior para o sexo masculino. O nível "I" assume uma variabilidade intermediária em relação aos outros 2 níveis.


##### D. Construção dos intervalos de confiança 95% para o coeficiente angular da reta de regressão para cada nível da variável sex. As retas de regressão para diferentes níveis parecem ter mesma inclinação? O que se pode concluir?
```{r conf_3}
conf_2f = confint.lm(reg_lin_2f, level = 0.95)
conf_2m = confint.lm(reg_lin_2m, level = 0.95)
conf_2i = confint.lm(reg_lin_2i, level = 0.95)


conf_2f
conf_2m
conf_2i
```
Os intervalos de confiança de $\beta_1$ para o nível feminino são um pouco inferiores em relação ao nível masculino. Pelo fato de que tais intervalos não se intersectam, é bastante provável que $\beta_1$ para a população feminina é menor que $\beta_1$ para a população masculina, isto é, o comprimento da concha cresce menos com o crescimento do peso da concha. Já o intervalo de confiança de $\beta_1$ para o nível sex = "I" assume valores bem maiores, o que sugere que a inclinação da reta de tendência é maior para este nível.

##### E. Construção dos intervalos de confiança para a resposta esperada correspondendo a shell_w = 50, para cada nível da variável sex. O que se pode concluir?
```{r Inf sobre a resposta esperada}

# novo valor da variável explicativa
Xh <- data.frame(shell_w = 50)

#F
# intervalo de confiança
ip2_f <- predict.lm(reg_lin_2f, newdata = Xh, 
           interval="confidence", level = 0.95)
ip2_f
#M
# intervalo de confiança
ip2_m <- predict.lm(reg_lin_2m, newdata = Xh, 
           interval="confidence", level = 0.95)
ip2_m

#I
# intervalo de confiança
ip2_i <- predict.lm(reg_lin_2i, newdata = Xh, 
           interval="confidence", level = 0.95)
ip2_i

```
A resposta esperada média está no intervalo de "lwr" a "upr", o qual é centrado em "fit", com 95% de confiança. Assim, os valores esperados de comprimento da concha para um valor de peso da concha igual a 50g, nos modelos de regressão construídos para a amostra estudada , são maiores para o nível "I" e menores para o nível "F", assumindo valores intermediários para nível "F".

##### F. Faz sentido aplicar alguma transformação à variável explicativa? Em caso positivo, replique os itens anteriores para um modelo para a variável explicativa transformada.

Primeramente, foram aplicadas algumas transformações à variável explicativa `shell_w`.

```{r transf2}
ggplot(abalone) +
  geom_point(aes(x= shell_w, y = length), na.rm = TRUE)

ggplot(abalone) +
  geom_point(aes(x= sqrt(shell_w), y = length), na.rm = TRUE)

ggplot(abalone) +
  geom_point(aes(x= 1/shell_w, y = length), na.rm = TRUE)

ggplot(abalone) +
  geom_point(aes(x= log2(shell_w), y = length), na.rm = TRUE)
```

Dessa forma, a partir dos gráficos gerados acima, é possivel perceber que a transformação `sqrt(sheel_w)` é viável. Logo, foram repetidos todos os passos anteriormente para a transformação realizada.

1. Obtendo os modelos de regressão ajustados.

```{r variaveis_transf}
# Constrói nova base de dados para análise
abalone_len_sqrtsh <- abalone |>
  # cria nova variável `sqrt_sh`
  mutate(sqrt_sh  = sqrt(shell_w))
```

```{r sumary_tranf}
summary(abalone_len_sqrtsh)
```

```{r filtrar sexo p shell_w tranf}

abalone3_F = abalone_len_sqrtsh[abalone_len_sqrtsh$sex == "F", c(2, 10)];
abalone3_M = abalone_len_sqrtsh[abalone_len_sqrtsh$sex == "M", c(2, 10)];
abalone3_I = abalone_len_sqrtsh[abalone_len_sqrtsh$sex == "I", c(2, 10)];

```

```{r modelos ajustado p shell_w por sexo tranf}
reg_lin_3f = lm(length ~ sqrt_sh, data = abalone3_F)

b0_3f = summary(reg_lin_3f)$coefficients[1];
b1_3f = summary(reg_lin_3f)$coefficients[2];


reg_lin_3m = lm(length ~ sqrt_sh, data = abalone3_M)

b0_3m = summary(reg_lin_3m)$coefficients[1];
b1_3m = summary(reg_lin_3m)$coefficients[2];

reg_lin_3i = lm(length ~ sqrt_sh, data = abalone3_I)

b0_3i = summary(reg_lin_3i)$coefficients[1];
b1_3i = summary(reg_lin_3i)$coefficients[2];

```

```{r retas ajustadas tranf}
reg_lin_3f
reg_lin_3m
reg_lin_3i
```
**Modelos Ajustados**
  
  1. Para `sex` igual a `F`: `length =   0.2195 + 0.6694.sqrt_sh`
  
  2. Para `sex` igual a `M`: `length =   0.1909 + 0.7201 .sqrt_sh`
  
  3. Para `sex` igual a `I`: `length =   0.1348 + 0.8702.sqrt_sh`

```{r plot transf}
#| message: false
# gera gráfico de dispersão
ggplot(abalone3_F, aes(x = sqrt_sh, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)

# gera gráfico de dispersão
ggplot(abalone3_M, aes(x = sqrt_sh, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)

# gera gráfico de dispersão
ggplot(abalone3_I, aes(x = sqrt_sh, y = length)) +
  geom_point() +
  # adiciona reta de regressão estimada 
  geom_smooth(method = lm, se = FALSE)
```

2. As funções de regressão estimadas são semelhantes para todos os níveis da variável sex? Discuta.

As retas de regressão encontradas diferem para cada nível da variável sex. Há uma descrepância maior da reta de regressão do nível sex = "I", em relação aos outros níveis, os quais apresentam retas de regressão semelhantes. 


```{r corr tranf}
#F
cor(abalone3_F$length, abalone3_F$sqrt_sh)
#M
cor(abalone3_M$length, abalone3_M$sqrt_sh)
#I
cor(abalone3_I$length, abalone3_I$sqrt_sh)
```
Verifica-se, também, que a correlação entre as variáveis para os 3 níveis de sex assumem valores próximos a 1, o que indica que a as variáveis possuem uma boa correlação e que esta é positiva. Nota-se que os coeficientes de correlação estão mais próximos de 1 após a transformação.

3. Cálculo o MSE para cada nível da variável sex. 
```{r mse tranf}
mse_3f = mean(residuals(summary(reg_lin_3f))^2)
mse_3m = mean(residuals(summary(reg_lin_3m))^2)
mse_3i = mean(residuals(summary(reg_lin_3i))^2)

mse_3f
mse_3m
mse_3i
```

O MSE assume valores baixos para os 3 modelos, o que ratifica que as variáveis são bem correlacionadas. No entanto, há diferenças dos valores entre os 3 modelos, o que indica uma variabilidade menor para conjunto de dados para o sexo indefindo e uma variabilidade maior para o sexo masculino. O nível "F", nesse caso, assume uma variabilidade próxima àquela obtida para o sexo masculino.

4. Construção dos intervalos de confiança 95% para o coeficiente angular da reta de regressão para cada nível da variável sex.
```{r conf_3 tranf}
conf_3f = confint.lm(reg_lin_3f, level = 0.95)
conf_3m = confint.lm(reg_lin_3m, level = 0.95)
conf_3i = confint.lm(reg_lin_3i, level = 0.95)


conf_3f
conf_3m
conf_3i
```
5. Construção intervalos de confiança para a resposta esperada correspondendo a shell_w = 50, para cada nível da variável sex. O que se pode concluir?
```{r prev_transf}
# novo valor da variável explicativa
Xh <- data.frame(sqrt_sh = sqrt(50))

#F
# intervalo de confiança
ip3_f <- predict.lm(reg_lin_3f, newdata = Xh, 
           interval="confidence", level = 0.95)
ip3_f
#M
# intervalo de confiança
ip3_m <- predict.lm(reg_lin_3m, newdata = Xh, 
           interval="confidence", level = 0.95)
ip3_m

#I
# intervalo de confiança
ip3_i <- predict.lm(reg_lin_3i, newdata = Xh, 
           interval="confidence", level = 0.95)
ip3_i
```

### Diagnóstico

####Parte 1: Realização do diagnóstico por meio da análise dos resíduos.

1. Para cada um dos modelos de regressão ajustados no item (1) da seção anterior, realize o diagnóstico através da análise dos resíduos e apresente um resumo de suas conclusões. O modelo de regressão linear simples clássico é adequado a alguma das situações investigadas?

#####Par `length`-`diameter`:

Para cada um dos modelos de regressão ajustados na Parte 1 da seção anterior foi realizada o diagnóstico por meio da análise dos resíduos.

**Linearidade**

Primeiramente, foi analisada a linearidade.

```{r diagmod1}
abalone_rls_len_diam
# Resumo da regressão para o par length-diameter
summary(abalone_rls_len_diam)
```

```{r linear_res}
#| layout-ncol: 2

# Constrói tabela com dados do modelo length ~ diameter
abalone_rls_len_diam_data <- abalone %>%
  # inclui coluna com valores ajustados
  mutate(fitted = abalone_rls_len_diam$fit) %>%
  mutate(resid = abalone_rls_len_diam$res)

# Gera gráficos dos resíduos:
ggplot(abalone_rls_len_diam_data, aes(x = fitted, y = resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggtitle("dados originais: modelo length ~ diameter") +
  labs(y = "resíduos", x = "resposta ajustada (length)")

ggplot(abalone_rls_len_diam_data, aes(x = diameter, y = resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggtitle("dados originais: modelo length ~ diameter") +
  labs(y = "resíduos", x = "variável explicativa (diameter)")
```

Verifica-se um padrão linear dos gráficos de resíduos tanto para a variável de resposta ajustada `length` quanto para a variável explicativa `diameter`.

*Homoscedasticidade*

Aparentemente não há um "efeito cone" nesse caso, porém foi feita análise da variância dos erros.

```{r homoscedasticidade}
#| layout-ncol: 2

# para dados transformados: resid x mpg_hat; resid x inv_hp
ggplot(abalone_rls_len_diam_data, aes(x = fitted, y = abs(resid))) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggtitle("dados transformados: modelo length ~ diameter") +
  labs(y = "|resíduos|", x = "resposta ajustada (length)")

ggplot(abalone_rls_len_diam_data, aes(x = diameter, y = abs(resid))) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggtitle("dados transformados: modelo length ~ diameter") +
  labs(y = "|resíduos|", x = "variável explicativa (diameter)")

```

Dessa forma, é possível verificar que realmente não há um "efeito cone". A partir do **Teste de Breusch-Pagan** foi obtida uma evidência formal acerca da constância da variância.

  - Hipótese Nula: variância constante
  - Hipótese Alternativa: variância não é constante.
  
```{r bp_test1, message=FALSE, warning=FALSE}
# Teste de Homoscedasticidade de Breusch-Pagan
# Ho: sigma^2  = cte
# Ha: sigma^2 != cte

library(lmtest)
bptest(abalone_rls_len_diam)
```
Logo, existem eveidências suficientes para rejeitar a hipótese nula de que a variância é constante, pois o *p*-valor obtido é menor do que 0.05. A partir do gráfico acima, também é possível suspeitar que existem *outliers* na amostra.

**Outliers**

Em seguida, foi realizada a análise dos resíduos padronizados a fim de verificar a existência de *outliers*.

2. Ajuste um modelo de regressão linear simples para a variável `length` como função de `diameter` após excluir as observações 1211 (X = 0.375 e Y = 0.185) e 4088 (X = 0.365 e Y = 0.61). Obtenha intervalos de previsão de 95% de confiança para novas observações que apresentam valores da variável explicativa iguais a 0.375 e 0.365. As observações eliminadas encontram-se nos limites dos intervalos de previsão obtidos? Discuta o significado dos resultados obtidos.

Primeiramente, foram retirados do *dataset* as observações em questão para então realizar a previsão com 95% de confiança.

```{r retira_valor1}
#Retira os valores requisitados e armazena em uma nova variável
abalone_diag <- abalone |>
  filter(diameter != 0.375 | length != 0.185) |>
  filter(diameter != 0.365 | length != 0.61 )

abalone_diag
```


3. Para os modelos considerando cada nível da variável `sex` no item (2) da seção anterior, realize o diagnóstico através da análise dos resíduos. Todos aparentam ter mesma variância dos erros? Que conclusões é possível obter a partir da análise?

----